import logging
from typing import Dict, List, Optional
from datetime import datetime

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def generar_recomendaciones(emociones: List[Dict], audio: Dict, diagnostico: Optional[str] = None) -> List[str]:
    """
    Genera recomendaciones personalizadas basadas en an√°lisis emocional y de audio.
    
    Args:
        emociones (List[Dict]): Resultados del an√°lisis emocional
        audio (Dict): Resultados del an√°lisis de audio
        diagnostico (str): Diagn√≥stico del ni√±o (opcional)
        
    Returns:
        List[str]: Lista de recomendaciones personalizadas
    """
    recomendaciones = []
    
    try:
        # An√°lisis de contexto emocional
        contexto_emocional = _analizar_contexto_emocional(emociones)
        contexto_comunicativo = _analizar_contexto_comunicativo(audio)
        
        # Recomendaciones basadas en diagn√≥stico
        if diagnostico:
            recomendaciones.extend(_generar_recomendaciones_diagnostico(diagnostico, contexto_emocional, contexto_comunicativo))
        
        # Recomendaciones basadas en emociones
        recomendaciones.extend(_generar_recomendaciones_emocionales(contexto_emocional))
        
        # Recomendaciones basadas en comunicaci√≥n
        recomendaciones.extend(_generar_recomendaciones_comunicativas(contexto_comunicativo))
        
        # Recomendaciones integradas
        recomendaciones.extend(_generar_recomendaciones_integradas(contexto_emocional, contexto_comunicativo, diagnostico))
        
        # Filtrar duplicados manteniendo orden
        recomendaciones_unicas = []
        for rec in recomendaciones:
            if rec not in recomendaciones_unicas:
                recomendaciones_unicas.append(rec)
        
        # Si no hay recomendaciones espec√≠ficas, agregar por defecto
        if not recomendaciones_unicas:
            recomendaciones_unicas = _generar_recomendaciones_por_defecto()
        
        logger.info(f"Generadas {len(recomendaciones_unicas)} recomendaciones personalizadas")
        return recomendaciones_unicas
        
    except Exception as e:
        logger.error(f"Error generando recomendaciones: {e}")
        return _generar_recomendaciones_por_defecto()

def _analizar_contexto_emocional(emociones: List[Dict]) -> Dict:
    """
    Analiza el contexto emocional del ni√±o basado en los resultados.
    
    Args:
        emociones (List[Dict]): Resultados emocionales
        
    Returns:
        Dict: Contexto emocional analizado
    """
    if not emociones:
        return {"patron": "sin_datos", "emociones_detectadas": 0}
    
    # Contar emociones y calcular m√©tricas
    conteo_emociones = {}
    confianzas = []
    frames_con_emociones = 0
    
    for frame_result in emociones:
        emociones_frame = frame_result.get('emociones', [])
        if emociones_frame:
            frames_con_emociones += 1
            
        for emocion_data in emociones_frame:
            emocion = emocion_data.get('emotion', 'Unknown')
            confianza = emocion_data.get('confidence', 0.0)
            
            conteo_emociones[emocion] = conteo_emociones.get(emocion, 0) + 1
            confianzas.append(confianza)
    
    total_detecciones = sum(conteo_emociones.values())
    
    # Determinar emoci√≥n predominante
    emocion_predominante = max(conteo_emociones, key=conteo_emociones.get) if conteo_emociones else "Unknown"
    porcentaje_predominante = (conteo_emociones.get(emocion_predominante, 0) / total_detecciones * 100) if total_detecciones > 0 else 0
    
    # Calcular estabilidad emocional
    estabilidad = "alta" if porcentaje_predominante > 60 else "media" if porcentaje_predominante > 40 else "baja"
    
    # Clasificar emociones
    emociones_positivas = ["Happy", "Surprise"]
    emociones_negativas = ["Sad", "Angry", "Fear", "Disgust"]
    emociones_neutras = ["Neutral"]
    
    positivas_count = sum(conteo_emociones.get(emo, 0) for emo in emociones_positivas)
    negativas_count = sum(conteo_emociones.get(emo, 0) for emo in emociones_negativas)
    neutras_count = sum(conteo_emociones.get(emo, 0) for emo in emociones_neutras)
    
    # Determinar patr√≥n emocional general
    if total_detecciones == 0:
        patron = "sin_detecciones"
    elif negativas_count > positivas_count * 1.5:
        patron = "predominio_negativo"
    elif positivas_count > negativas_count * 1.5:
        patron = "predominio_positivo"
    elif neutras_count > (positivas_count + negativas_count):
        patron = "predominio_neutral"
    else:
        patron = "equilibrado"
    
    # Evaluar variabilidad emocional
    variabilidad = len(conteo_emociones)
    if variabilidad <= 2:
        tipo_variabilidad = "baja"
    elif variabilidad <= 4:
        tipo_variabilidad = "media"
    else:
        tipo_variabilidad = "alta"
    
    return {
        "patron": patron,
        "emocion_predominante": emocion_predominante,
        "porcentaje_predominante": porcentaje_predominante,
        "estabilidad": estabilidad,
        "emociones_detectadas": total_detecciones,
        "variabilidad": tipo_variabilidad,
        "distribucion": conteo_emociones,
        "confianza_promedio": sum(confianzas) / len(confianzas) if confianzas else 0,
        "emociones_positivas": positivas_count,
        "emociones_negativas": negativas_count,
        "emociones_neutras": neutras_count,
        "cobertura_frames": (frames_con_emociones / len(emociones) * 100) if emociones else 0
    }

def _analizar_contexto_comunicativo(audio: Dict) -> Dict:
    """
    Analiza el contexto comunicativo basado en los resultados de audio.
    
    Args:
        audio (Dict): Resultados del an√°lisis de audio
        
    Returns:
        Dict: Contexto comunicativo analizado
    """
    if not audio or audio.get('error'):
        return {"nivel": "sin_datos", "calidad": "no_evaluado"}
    
    # Extraer m√©tricas b√°sicas
    intentos = audio.get('intentos_comunicacion', 0)
    palabras_totales = audio.get('palabras_totales', 0)
    calidad = audio.get('calidad_comunicacion', 'no_evaluado')
    transcripcion = audio.get('transcription', '')
    palabras_infantiles = audio.get('palabras_infantiles', [])
    
    # Determinar nivel comunicativo
    if intentos == 0 and palabras_totales == 0:
        nivel = "no_verbal"
    elif intentos < 3:
        nivel = "pre_verbal"
    elif intentos < 8:
        nivel = "verbal_emergente"
    else:
        nivel = "verbal_funcional"
    
    # Evaluar claridad
    if not transcripcion:
        claridad = "inaudible"
    elif len(transcripcion) < 10:
        claridad = "muy_limitada"
    elif len(transcripcion) < 50:
        claridad = "limitada"
    else:
        claridad = "clara"
    
    # Evaluar complejidad del lenguaje
    if palabras_totales == 0:
        complejidad = "sin_lenguaje"
    elif palabras_totales < 5:
        complejidad = "palabras_simples"
    elif palabras_totales < 15:
        complejidad = "frases_basicas"
    else:
        complejidad = "lenguaje_elaborado"
    
    # Evaluar apropiaci√≥n del vocabulario
    apropiacion_infantil = len(palabras_infantiles) / max(palabras_totales, 1) if palabras_totales > 0 else 0
    
    return {
        "nivel": nivel,
        "calidad": calidad,
        "claridad": claridad,
        "complejidad": complejidad,
        "intentos_comunicativos": intentos,
        "palabras_totales": palabras_totales,
        "palabras_infantiles_count": len(palabras_infantiles),
        "apropiacion_infantil": apropiacion_infantil,
        "longitud_transcripcion": len(transcripcion),
        "tiene_verbalizacion": bool(transcripcion)
    }

def _generar_recomendaciones_diagnostico(diagnostico: str, contexto_emocional: Dict, contexto_comunicativo: Dict) -> List[str]:
    """
    Genera recomendaciones espec√≠ficas basadas en el diagn√≥stico.
    
    Args:
        diagnostico (str): Diagn√≥stico del ni√±o
        contexto_emocional (Dict): Contexto emocional
        contexto_comunicativo (Dict): Contexto comunicativo
        
    Returns:
        List[str]: Recomendaciones espec√≠ficas por diagn√≥stico
    """
    recomendaciones = []
    diagnostico_lower = diagnostico.lower()
    
    # AUTISMO / TEA
    if any(term in diagnostico_lower for term in ['autismo', 'tea', 'espectro']):
        recomendaciones.extend([
            "üîÑ Implementar rutinas estructuradas y predecibles con apoyos visuales",
            "üéØ Usar sistemas de comunicaci√≥n por intercambio de im√°genes (PECS) si la comunicaci√≥n verbal es limitada",
            "üåà Crear un entorno sensorial controlado, evitando sobreestimulaci√≥n"
        ])
        
        # Espec√≠ficas por patr√≥n emocional
        if contexto_emocional["patron"] == "predominio_negativo":
            recomendaciones.append("‚ö†Ô∏è Monitorear desregulaci√≥n emocional; implementar estrategias de autorregulaci√≥n espec√≠ficas para TEA")
        
        # Espec√≠ficas por comunicaci√≥n
        if contexto_comunicativo["nivel"] == "no_verbal":
            recomendaciones.append("üì± Evaluar urgentemente sistemas de comunicaci√≥n aumentativa y alternativa (CAA)")
        elif contexto_comunicativo["nivel"] == "verbal_emergente":
            recomendaciones.append("üó£Ô∏è Fomentar ecolalia funcional y expansi√≥n de vocabulario tem√°tico")
    
    # TDAH
    elif any(term in diagnostico_lower for term in ['tdah', 'atencion', 'hiperactividad', 'deficit']):
        recomendaciones.extend([
            "‚è∞ Dividir actividades en segmentos de 10-15 minutos con descansos activos",
            "üéØ Usar recordatorios visuales y auditivos para transiciones",
            "üèÉ Incorporar movimiento f√≠sico en las actividades de aprendizaje"
        ])
        
        if contexto_emocional.get("variabilidad") == "alta":
            recomendaciones.append("üìä La alta variabilidad emocional puede indicar desregulaci√≥n t√≠pica del TDAH; considerar t√©cnicas de mindfulness adaptadas")
        
        if contexto_comunicativo["intentos_comunicativos"] < 5:
            recomendaciones.append("üí¨ La comunicaci√≥n limitada puede estar relacionada con impulsividad; trabajar t√©cnicas de pausa y reflexi√≥n")
    
    # S√çNDROME DE DOWN
    elif any(term in diagnostico_lower for term in ['down', 'trisomia']):
        recomendaciones.extend([
            "üëÅÔ∏è Priorizar aprendizaje visual sobre auditivo en todas las intervenciones",
            "üîÅ Implementar repetici√≥n estructurada con refuerzo positivo inmediato",
            "üë• Fomentar interacciones sociales para desarrollo de habilidades comunicativas"
        ])
        
        if contexto_comunicativo["claridad"] == "muy_limitada":
            recomendaciones.append("üëÑ Considerar terapia orofacial para mejorar articulaci√≥n y claridad del habla")
    
    # PAR√ÅLISIS CEREBRAL
    elif any(term in diagnostico_lower for term in ['paralisis', 'cerebral', 'pc']):
        recomendaciones.extend([
            "üîß Implementar adaptaciones f√≠sicas y tecnol√≥gicas seg√∫n capacidades motoras",
            "üì± Evaluar dispositivos de comunicaci√≥n asistiva si hay limitaciones del habla",
            "ü§ù Coordinar con terapia ocupacional y fisioterapia para enfoque integral"
        ])
        
        if contexto_comunicativo["nivel"] == "no_verbal":
            recomendaciones.append("üñ•Ô∏è Priorizar sistemas de comunicaci√≥n por switch o mirada seg√∫n capacidades motoras")
    
    # DISCAPACIDAD INTELECTUAL
    elif any(term in diagnostico_lower for term in ['intelectual', 'cognitiva', 'retraso']):
        recomendaciones.extend([
            "üìö Adaptar contenidos a nivel cognitivo con materiales concretos y visuales",
            "üéì Dividir objetivos en peque√±os pasos con celebraci√≥n de logros",
            "üë®‚Äçüë©‚Äçüëß Involucrar activamente a la familia en estrategias de refuerzo"
        ])
        
        if contexto_emocional["patron"] == "predominio_negativo":
            recomendaciones.append("üòä La frustraci√≥n puede estar relacionada con demandas cognitivas; ajustar expectativas y aumentar apoyo")
    
    # TRASTORNOS DEL LENGUAJE
    elif any(term in diagnostico_lower for term in ['lenguaje', 'habla', 'comunicacion']):
        recomendaciones.extend([
            "üó£Ô∏è Implementar terapia del lenguaje intensiva con enfoque funcional",
            "üéµ Usar t√©cnicas de prosodia y ritmo para mejorar fluidez",
            "üëÇ Fomentar comprensi√≥n auditiva antes que expresi√≥n verbal"
        ])
        
        if contexto_comunicativo["complejidad"] == "sin_lenguaje":
            recomendaciones.append("üö® Evaluaci√≥n integral del lenguaje urgente; considerar trastornos asociados")
    
    return recomendaciones

def _generar_recomendaciones_emocionales(contexto_emocional: Dict) -> List[str]:
    """
    Genera recomendaciones basadas en el patr√≥n emocional detectado.
    
    Args:
        contexto_emocional (Dict): Contexto emocional analizado
        
    Returns:
        List[str]: Recomendaciones emocionales
    """
    recomendaciones = []
    patron = contexto_emocional.get("patron", "sin_datos")
    emocion_predominante = contexto_emocional.get("emocion_predominante", "Unknown")
    
    # Recomendaciones por patr√≥n general
    if patron == "predominio_negativo":
        recomendaciones.extend([
            "‚ö†Ô∏è Se detect√≥ predominio de emociones negativas - evaluaci√≥n psicoemocional recomendada",
            "üåü Implementar actividades de regulaci√≥n emocional y bienestar",
            "üé® Fomentar expresi√≥n creativa (arte, m√∫sica) para canalizar emociones",
            "üíù Aumentar refuerzos positivos y celebraci√≥n de logros peque√±os"
        ])
    
    elif patron == "predominio_positivo":
        recomendaciones.extend([
            "üòä Excelente regulaci√≥n emocional detectada - mantener estrategias actuales",
            "üìà Aprovechar estado emocional positivo para nuevos aprendizajes",
            "üéØ Usar emociones positivas como refuerzo natural en actividades"
        ])
    
    elif patron == "predominio_neutral":
        recomendaciones.extend([
            "üòê Expresi√≥n emocional limitada - estimular variabilidad expresiva",
            "üé≠ Implementar juegos de expresi√≥n facial y reconocimiento emocional",
            "üìö Usar cuentos e historias sociales para ense√±ar emociones"
        ])
    
    # Recomendaciones por emoci√≥n espec√≠fica predominante
    if emocion_predominante == "Sad":
        porcentaje = contexto_emocional.get("porcentaje_predominante", 0)
        if porcentaje > 50:
            recomendaciones.append("üò¢ Alta frecuencia de tristeza detectada - considerar evaluaci√≥n de depresi√≥n infantil")
        recomendaciones.extend([
            "üéµ Implementar musicoterapia y actividades que generen bienestar",
            "ü§ó Aumentar tiempo de interacci√≥n social positiva y juego colaborativo",
            "üèÉ Incluir actividad f√≠sica regular para mejorar estado de √°nimo"
        ])
    
    elif emocion_predominante == "Angry":
        recomendaciones.extend([
            "üò§ Ense√±ar t√©cnicas de autorregulaci√≥n apropiadas para la edad",
            "üßò Implementar t√©cnicas de relajaci√≥n y mindfulness infantil",
            "üìñ Usar historias sociales sobre manejo de la frustraci√≥n",
            "üéØ Identificar y modificar disparadores de enojo"
        ])
    
    elif emocion_predominante == "Fear":
        recomendaciones.extend([
            "üò∞ Trabajar t√©cnicas de desensibilizaci√≥n gradual para miedos",
            "üõ°Ô∏è Crear entorno seguro y predecible para reducir ansiedad",
            "üéÆ Usar juego terap√©utico para procesar temores",
            "üë®‚Äçüë©‚Äçüëß Involucrar a cuidadores en estrategias de manejo de ansiedad"
        ])
    
    elif emocion_predominante == "Happy":
        recomendaciones.extend([
            "üéâ Estado emocional positivo detectado - excelente base para aprendizaje",
            "üìö Aprovechar motivaci√≥n alta para introducir nuevas habilidades",
            "üéØ Usar refuerzo positivo natural ya presente"
        ])
    
    # Recomendaciones por estabilidad emocional
    estabilidad = contexto_emocional.get("estabilidad", "media")
    if estabilidad == "baja":
        recomendaciones.append("üåä Variabilidad emocional alta detectada - trabajar estrategias de estabilizaci√≥n")
    elif estabilidad == "alta":
        if contexto_emocional.get("variabilidad") == "baja":
            recomendaciones.append("üìä Expresi√≥n emocional muy limitada - estimular rango expresivo")
    
    return recomendaciones

def _generar_recomendaciones_comunicativas(contexto_comunicativo: Dict) -> List[str]:
    """
    Genera recomendaciones basadas en el an√°lisis comunicativo.
    
    Args:
        contexto_comunicativo (Dict): Contexto comunicativo
        
    Returns:
        List[str]: Recomendaciones comunicativas
    """
    recomendaciones = []
    nivel = contexto_comunicativo.get("nivel", "sin_datos")
    claridad = contexto_comunicativo.get("claridad", "no_evaluado")
    
    # Recomendaciones por nivel comunicativo
    if nivel == "no_verbal":
        recomendaciones.extend([
            "üö® Ausencia de comunicaci√≥n verbal - evaluaci√≥n urgente de CAA (Comunicaci√≥n Aumentativa y Alternativa)",
            "üëã Fomentar comunicaci√≥n gestual y se√±alamiento funcional",
            "üì± Considerar aplicaciones de comunicaci√≥n por im√°genes (PECS digital)",
            "üéØ Establecer intenci√≥n comunicativa antes que forma verbal"
        ])
    
    elif nivel == "pre_verbal":
        recomendaciones.extend([
            "üó£Ô∏è Estimular vocalizaci√≥n mediante imitaci√≥n y juego vocal",
            "üéµ Usar t√©cnicas de comunicaci√≥n total (gesto + verbalizaci√≥n)",
            "üìñ Implementar rutinas de lectura interactiva diaria",
            "üëÑ Considerar estimulaci√≥n orofacial si hay dificultades articulatorias"
        ])
    
    elif nivel == "verbal_emergente":
        recomendaciones.extend([
            "üìà Expandir vocabulario funcional mediante rutinas diarias",
            "üîÑ Usar t√©cnicas de modelado y expansi√≥n de frases",
            "üé≠ Implementar juegos de imitaci√≥n vocal y verbal",
            "üìö Crear oportunidades de comunicaci√≥n espont√°nea"
        ])
    
    elif nivel == "verbal_funcional":
        recomendaciones.extend([
            "üí¨ Fomentar conversaci√≥n elaborada y narrativa",
            "üìñ Trabajar comprensi√≥n de textos y seguimiento de instrucciones complejas",
            "üéØ Desarrollar habilidades pragm√°ticas del lenguaje"
        ])
    
    # Recomendaciones por claridad
    if claridad == "inaudible" or claridad == "muy_limitada":
        recomendaciones.extend([
            "üëÇ Evaluaci√≥n audiol√≥gica para descartar p√©rdida auditiva",
            "üîä Trabajar proyecci√≥n de voz y articulaci√≥n",
            "üé§ Considerar amplificaci√≥n o sistemas FM si es necesario"
        ])
    
    elif claridad == "limitada":
        recomendaciones.append("üó£Ô∏è Terapia del habla enfocada en inteligibilidad")
    
    # Recomendaciones por complejidad
    complejidad = contexto_comunicativo.get("complejidad", "sin_lenguaje")
    if complejidad == "palabras_simples":
        recomendaciones.append("üîó Fomentar combinaci√≥n de palabras en frases simples")
    elif complejidad == "frases_basicas":
        recomendaciones.append("üìù Trabajar estructura gramatical b√°sica y ampliaci√≥n de frases")
    
    # Apropiaci√≥n del vocabulario infantil
    apropiacion = contexto_comunicativo.get("apropiacion_infantil", 0)
    if apropiacion < 0.3 and contexto_comunicativo.get("palabras_totales", 0) > 5:
        recomendaciones.append("üë∂ Fomentar vocabulario apropiado para la edad cronol√≥gica")
    
    return recomendaciones

def _generar_recomendaciones_integradas(contexto_emocional: Dict, contexto_comunicativo: Dict, diagnostico: str = None) -> List[str]:
    """
    Genera recomendaciones que integran aspectos emocionales y comunicativos.
    
    Args:
        contexto_emocional (Dict): Contexto emocional
        contexto_comunicativo (Dict): Contexto comunicativo  
        diagnostico (str): Diagn√≥stico si est√° disponible
        
    Returns:
        List[str]: Recomendaciones integradas
    """
    recomendaciones = []
    
    # Integraci√≥n emoci√≥n-comunicaci√≥n
    patron_emocional = contexto_emocional.get("patron", "")
    nivel_comunicativo = contexto_comunicativo.get("nivel", "")
    
    # Frustraci√≥n por limitaciones comunicativas
    if (patron_emocional == "predominio_negativo" and 
        contexto_emocional.get("emocion_predominante") in ["Angry", "Sad"] and
        nivel_comunicativo in ["no_verbal", "pre_verbal"]):
        
        recomendaciones.append("üîÑ La frustraci√≥n emocional puede estar relacionada con limitaciones comunicativas - priorizar desarrollo de comunicaci√≥n funcional")
    
    # Comunicaci√≥n limitada con patr√≥n neutral
    if (patron_emocional == "predominio_neutral" and 
        nivel_comunicativo in ["no_verbal", "pre_verbal"]):
        
        recomendaciones.append("üìà Combinar estimulaci√≥n emocional y comunicativa mediante juego interactivo estructurado")
    
    # Alta variabilidad emocional con comunicaci√≥n funcional
    if (contexto_emocional.get("variabilidad") == "alta" and 
        nivel_comunicativo == "verbal_funcional"):
        
        recomendaciones.append("üó£Ô∏è Usar habilidades verbales para ense√±ar autorregulaci√≥n emocional")
    
    # Recomendaciones por confianza en detecciones
    confianza_promedio = contexto_emocional.get("confianza_promedio", 0)
    if confianza_promedio < 0.5:
        recomendaciones.append("üì∏ Baja confianza en detecci√≥n emocional - considerar mejores condiciones de grabaci√≥n para futuros an√°lisis")
    
    # Cobertura de frames baja
    cobertura = contexto_emocional.get("cobertura_frames", 0)
    if cobertura < 50:
        recomendaciones.append("üé• Baja detecci√≥n facial - asegurar buena iluminaci√≥n y posici√≥n del ni√±o frente a la c√°mara")
    
    # Recomendaciones de seguimiento
    recomendaciones.extend([
        "üìÖ Realizar seguimiento en 2-3 semanas para evaluar progreso",
        "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Involucrar a todos los cuidadores en la implementaci√≥n de estrategias",
        "üìä Documentar cambios observados para ajustar intervenciones"
    ])
    
    return recomendaciones

def _generar_recomendaciones_por_defecto() -> List[str]:
    """
    Genera recomendaciones por defecto cuando no se pueden generar espec√≠ficas.
    
    Returns:
        List[str]: Recomendaciones por defecto
    """
    return [
        "üîç Realizar observaci√≥n sistem√°tica del comportamiento en diferentes contextos",
        "üìù Mantener registro diario de comunicaci√≥n y expresiones emocionales",
        "üë®‚Äç‚öïÔ∏è Consultar con equipo interdisciplinario para evaluaci√≥n completa",
        "üè† Crear ambiente estructurado y predecible en el hogar",
        "üí™ Reforzar fortalezas observadas mientras se trabajan √°reas de mejora",
        "üìà Establecer objetivos realistas y medibles a corto plazo",
        "ü§ù Mantener comunicaci√≥n constante entre familia y profesionales"
    ]

def generar_reporte_recomendaciones(recomendaciones: List[str], contexto_emocional: Dict, 
                                   contexto_comunicativo: Dict, diagnostico: str = None) -> Dict:
    """
    Genera reporte estructurado de recomendaciones con contexto detallado.
    
    Args:
        recomendaciones (List[str]): Lista de recomendaciones
        contexto_emocional (Dict): Contexto emocional
        contexto_comunicativo (Dict): Contexto comunicativo
        diagnostico (str): Diagn√≥stico del ni√±o
        
    Returns:
        Dict: Reporte estructurado
    """
    # Categorizar recomendaciones por tipo
    categorias = {
        "urgentes": [],
        "emocionales": [],
        "comunicativas": [],
        "familiares": [],
        "profesionales": [],
        "seguimiento": []
    }
    
    for rec in recomendaciones:
        if any(palabra in rec.lower() for palabra in ['urgente', 'üö®', 'inmediato', 'evaluar urgentemente']):
            categorias["urgentes"].append(rec)
        elif any(palabra in rec.lower() for palabra in ['emocional', 'üò¢', 'üò§', 'üò∞', 'üßò', 'regulaci√≥n']):
            categorias["emocionales"].append(rec)
        elif any(palabra in rec.lower() for palabra in ['comunicaci√≥n', 'üó£Ô∏è', 'üì±', 'verbal', 'lenguaje', 'caa']):
            categorias["comunicativas"].append(rec)
        elif any(palabra in rec.lower() for palabra in ['familia', 'üë®‚Äçüë©‚Äçüëß', 'cuidadores', 'hogar']):
            categorias["familiares"].append(rec)
        elif any(palabra in rec.lower() for palabra in ['profesional', 'üë®‚Äç‚öïÔ∏è', 'terapia', 'evaluaci√≥n']):
            categorias["profesionales"].append(rec)
        elif any(palabra in rec.lower() for palabra in ['seguimiento', 'üìÖ', 'documentar', 'progreso']):
            categorias["seguimiento"].append(rec)
    
    return {
        "timestamp": datetime.now().isoformat(),
        "diagnostico": diagnostico or "No especificado",
        "resumen_emocional": contexto_emocional,
        "resumen_comunicativo": contexto_comunicativo,
        "recomendaciones_por_categoria": categorias,
        "total_recomendaciones": len(recomendaciones),
        "nivel_prioridad": "alta" if categorias["urgentes"] else "media" if categorias["profesionales"] else "normal"
    }

def validar_recomendaciones(recomendaciones: List[str]) -> Dict[str, bool]:
    """
    Valida la calidad y completitud de las recomendaciones generadas.
    
    Args:
        recomendaciones (List[str]): Lista de recomendaciones
        
    Returns:
        Dict[str, bool]: Resultados de validaci√≥n
    """
    validacion = {
        "tiene_recomendaciones": len(recomendaciones) > 0,
        "longitud_adecuada": 3 <= len(recomendaciones) <= 15,
        "incluye_emocionales": any("emocional" in rec.lower() or any(emoji in rec for emoji in ['üò¢', 'üò§', 'üò∞', 'üßò']) for rec in recomendaciones),
        "incluye_comunicativas": any("comunicaci√≥n" in rec.lower() or "verbal" in rec.lower() or "üó£Ô∏è" in rec for rec in recomendaciones),
        "incluye_seguimiento": any("seguimiento" in rec.lower() or "üìÖ" in rec for rec in recomendaciones),
        "sin_duplicados": len(recomendaciones) == len(set(recomendaciones))
    }
    
    validacion["es_completa"] = all([
        validacion["tiene_recomendaciones"],
        validacion["longitud_adecuada"],
        validacion["sin_duplicados"]
    ])
    
    return validacion

